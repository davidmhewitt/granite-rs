// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::DrawingColor;
use glib::{
    prelude::*,
    signal::{connect_raw, SignalHandlerId},
    translate::*,
};
use std::{boxed::Box as Box_, fmt, mem::transmute};

glib::wrapper! {
    #[doc(alias = "GraniteDrawingBufferSurface")]
    pub struct DrawingBufferSurface(Object<ffi::GraniteDrawingBufferSurface, ffi::GraniteDrawingBufferSurfaceClass>);

    match fn {
        type_ => || ffi::granite_drawing_buffer_surface_get_type(),
    }
}

impl DrawingBufferSurface {
    pub const NONE: Option<&'static DrawingBufferSurface> = None;

    #[doc(alias = "granite_drawing_buffer_surface_new")]
    pub fn new(width: i32, height: i32) -> DrawingBufferSurface {
        assert_initialized_main_thread!();
        unsafe { from_glib_full(ffi::granite_drawing_buffer_surface_new(width, height)) }
    }

    #[doc(alias = "granite_drawing_buffer_surface_new_with_buffer_surface")]
    pub fn with_buffer_surface(
        width: i32,
        height: i32,
        model: &impl IsA<DrawingBufferSurface>,
    ) -> DrawingBufferSurface {
        skip_assert_initialized!();
        unsafe {
            from_glib_full(ffi::granite_drawing_buffer_surface_new_with_buffer_surface(
                width,
                height,
                model.as_ref().to_glib_none().0,
            ))
        }
    }

    // rustdoc-stripper-ignore-next
    /// Creates a new builder-pattern struct instance to construct [`DrawingBufferSurface`] objects.
    ///
    /// This method returns an instance of [`DrawingBufferSurfaceBuilder`](crate::builders::DrawingBufferSurfaceBuilder) which can be used to create [`DrawingBufferSurface`] objects.
    pub fn builder() -> DrawingBufferSurfaceBuilder {
        DrawingBufferSurfaceBuilder::new()
    }
}

impl Default for DrawingBufferSurface {
    fn default() -> Self {
        glib::object::Object::new::<Self>()
    }
}

// rustdoc-stripper-ignore-next
/// A [builder-pattern] type to construct [`DrawingBufferSurface`] objects.
///
/// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct DrawingBufferSurfaceBuilder {
    builder: glib::object::ObjectBuilder<'static, DrawingBufferSurface>,
}

impl DrawingBufferSurfaceBuilder {
    fn new() -> Self {
        Self {
            builder: glib::object::Object::builder(),
        }
    }

    pub fn surface(self, surface: &cairo::Surface) -> Self {
        Self {
            builder: self.builder.property("surface", surface),
        }
    }

    pub fn width(self, width: i32) -> Self {
        Self {
            builder: self.builder.property("width", width),
        }
    }

    pub fn height(self, height: i32) -> Self {
        Self {
            builder: self.builder.property("height", height),
        }
    }

    // rustdoc-stripper-ignore-next
    /// Build the [`DrawingBufferSurface`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> DrawingBufferSurface {
        self.builder.build()
    }
}

pub trait DrawingBufferSurfaceExt: 'static {
    #[doc(alias = "granite_drawing_buffer_surface_get_surface")]
    #[doc(alias = "get_surface")]
    fn surface(&self) -> Option<cairo::Surface>;

    #[doc(alias = "granite_drawing_buffer_surface_get_width")]
    #[doc(alias = "get_width")]
    fn width(&self) -> i32;

    #[doc(alias = "granite_drawing_buffer_surface_get_height")]
    #[doc(alias = "get_height")]
    fn height(&self) -> i32;

    #[doc(alias = "granite_drawing_buffer_surface_get_context")]
    #[doc(alias = "get_context")]
    fn context(&self) -> Option<cairo::Context>;

    #[doc(alias = "granite_drawing_buffer_surface_clear")]
    fn clear(&self);

    #[doc(alias = "granite_drawing_buffer_surface_load_to_pixbuf")]
    fn load_to_pixbuf(&self) -> Option<gdk_pixbuf::Pixbuf>;

    #[doc(alias = "granite_drawing_buffer_surface_average_color")]
    fn average_color(&self) -> Option<DrawingColor>;

    #[doc(alias = "granite_drawing_buffer_surface_fast_blur")]
    fn fast_blur(&self, radius: i32, process_count: i32);

    #[doc(alias = "granite_drawing_buffer_surface_exponential_blur")]
    fn exponential_blur(&self, radius: i32);

    #[doc(alias = "granite_drawing_buffer_surface_gaussian_blur")]
    fn gaussian_blur(&self, radius: i32);

    fn set_surface(&self, surface: Option<&cairo::Surface>);

    fn set_width(&self, width: i32);

    fn set_height(&self, height: i32);

    #[doc(alias = "surface")]
    fn connect_surface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "width")]
    fn connect_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "height")]
    fn connect_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "context")]
    fn connect_context_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<DrawingBufferSurface>> DrawingBufferSurfaceExt for O {
    fn surface(&self) -> Option<cairo::Surface> {
        unsafe {
            from_glib_none(ffi::granite_drawing_buffer_surface_get_surface(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn width(&self) -> i32 {
        unsafe { ffi::granite_drawing_buffer_surface_get_width(self.as_ref().to_glib_none().0) }
    }

    fn height(&self) -> i32 {
        unsafe { ffi::granite_drawing_buffer_surface_get_height(self.as_ref().to_glib_none().0) }
    }

    fn context(&self) -> Option<cairo::Context> {
        unsafe {
            from_glib_none(ffi::granite_drawing_buffer_surface_get_context(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn clear(&self) {
        unsafe {
            ffi::granite_drawing_buffer_surface_clear(self.as_ref().to_glib_none().0);
        }
    }

    fn load_to_pixbuf(&self) -> Option<gdk_pixbuf::Pixbuf> {
        unsafe {
            from_glib_full(ffi::granite_drawing_buffer_surface_load_to_pixbuf(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn average_color(&self) -> Option<DrawingColor> {
        unsafe {
            from_glib_full(ffi::granite_drawing_buffer_surface_average_color(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn fast_blur(&self, radius: i32, process_count: i32) {
        unsafe {
            ffi::granite_drawing_buffer_surface_fast_blur(
                self.as_ref().to_glib_none().0,
                radius,
                process_count,
            );
        }
    }

    fn exponential_blur(&self, radius: i32) {
        unsafe {
            ffi::granite_drawing_buffer_surface_exponential_blur(
                self.as_ref().to_glib_none().0,
                radius,
            );
        }
    }

    fn gaussian_blur(&self, radius: i32) {
        unsafe {
            ffi::granite_drawing_buffer_surface_gaussian_blur(
                self.as_ref().to_glib_none().0,
                radius,
            );
        }
    }

    fn set_surface(&self, surface: Option<&cairo::Surface>) {
        glib::ObjectExt::set_property(self.as_ref(), "surface", &surface)
    }

    fn set_width(&self, width: i32) {
        glib::ObjectExt::set_property(self.as_ref(), "width", &width)
    }

    fn set_height(&self, height: i32) {
        glib::ObjectExt::set_property(self.as_ref(), "height", &height)
    }

    fn connect_surface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_surface_trampoline<
            P: IsA<DrawingBufferSurface>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::GraniteDrawingBufferSurface,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(DrawingBufferSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::surface\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_surface_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_width_trampoline<
            P: IsA<DrawingBufferSurface>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::GraniteDrawingBufferSurface,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(DrawingBufferSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::width\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_width_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_height_trampoline<
            P: IsA<DrawingBufferSurface>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::GraniteDrawingBufferSurface,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(DrawingBufferSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::height\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_height_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_context_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_context_trampoline<
            P: IsA<DrawingBufferSurface>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::GraniteDrawingBufferSurface,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(DrawingBufferSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::context\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_context_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for DrawingBufferSurface {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("DrawingBufferSurface")
    }
}
